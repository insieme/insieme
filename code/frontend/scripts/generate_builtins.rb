# This is a helper script for dealing with the issue that clang cannot parse many GCC intrinsics.
# It searches for standard header include files named *intrin.h, and copies forward declarations,
# typedefs and enum declarations to the builtin_header directory of the Insieme source tree.
#
# By default, only missing headers are generated.
#
# NOTE: The script ignores preprocessor directives that are not simple #if(n)defs

require 'set'
require 'optparse'
require 'fileutils'

# generated file to which all typedefs are written
types_header_filename = "hacked_types.h"
# generated file containing dummy declarations for the GCC builtins we need
gcc_builtins_filename_src = "generate_builtins_gcc_builtins.template"
gcc_builtins_filename_dst = "generate_builtins_gcc_builtins.h"
# patterns of input files to be parsed - most of them end with the string 'intrin.h', but there are some exceptions
infile_pattern = /.*intrin.h|mm3dnow.h/

# these match all relevant constructs seen so far in standard intrinsics headers
function_pattern = /extern\s+__inline\s+([\w ]+)\s+(?:__attribute__\s*[_a-zA-Z0-9(,)\s+]*?)?\n(_[^\s]+)\s+\(([^\)]*?)\)/
enum_pattern = /(\w*)\s*enum\s+(\w*)([^}]+?})\s*(\w*);/
preprocessor_pattern = /^(#(?:if|else|endif|include).*)$/

# tokens to be removed/ignored
standard_tokens = %w(void char short int unsigned long float double const enum \*)

$options = {:insieme_builtins_dir => nil, :command => nil, :std_include_dirs => nil, :force => false, :quiet => false, :detect_via_compiler => nil}

parser = OptionParser.new do|opts|
	opts.banner = "Usage: ./generate_builtins.rb [options]"
	opts.on('-f', '--force', 'Force overwrite if present') do |f|
		$options[:force] = f;
	end

	opts.on('-q', '--quiet', 'Suppress all console output') do |q|
		$options[:quiet] = q;
	end

	opts.on('-d', '--detect-via-compiler compiler', String, 'Automatically detect standard header include directory by asking preprocessor of specified compiler') do |detect|
		$options[:detect_via_compiler] = detect;
	end

	opts.on('-i', '--input dirs', String, 'Standard header include directories (colon-separated)') do |std_inc_dirs|
		$options[:std_include_dirs] = std_inc_dirs.split(":");
	end

	opts.on('-o', '--output dir', String, 'Insieme builtin header directory') do |insieme_builtins_dir|
		$options[:insieme_builtins_dir] = insieme_builtins_dir;
	end

	opts.on('-h', '--help', 'Displays Help') do
		puts opts
		exit
	end
end

parser.parse!

raise OptionParser::MissingArgument if $options[:insieme_builtins_dir] == nil || ($options[:std_include_dir] == nil && $options[:detect_via_compiler] == nil)

def create_dir_if_not_exists(dirname)
	FileUtils.mkdir_p(dirname) unless File.directory?(dirname)
end

create_dir_if_not_exists($options[:insieme_builtins_dir])

def wrap_and_print(text, outfile)
	header = "// AUTOGENERATED HEADER\n"
	header += "//\n"
	header += "// This header file was auto-generated by generate_builtins.rb at " + Time.new.to_s + "\n"
	File.open(outfile, "w") do |outfile|
		puts "*** Writing #{File.path(outfile)}" if !$options[:quiet]
		outfile.write("#pragma once")
		outfile.write("\n\n#{header}\n")
		outfile.write("#ifdef __clang__\n\n")
		outfile.write(text)
		outfile.write("\n#endif // __clang__\n\n#{header}\n\n")
	end
end

if($options[:std_include_dirs] == nil && $options[:detect_via_compiler])
	compiler = "#{$options[:detect_via_compiler]}"
	preprocessor_cmd = "echo | #{compiler} -v -xc -E - 2>&1"
	preprocessor_output = `#{preprocessor_cmd}`
	# look for paths with a whitespace in front
	match = preprocessor_output.scan(/(^ \/[^ ]*$)/)
	if(match)
		$options[:std_include_dirs] = match.map{ |x| x[0].strip }
	else
		puts "Unable to parse preprocessor output from command \"#{preprocessor_cmd}\""
		exit 1
	end
end

types = Set.new
enums = Hash.new

$options[:std_include_dirs].each do |directory|
	# we glob over all header files here
	Dir.glob("#{directory}/**/*.h").each do |infile|
		# and filter out the ones not matching our input filename pattern
		if(!infile_pattern.match(File.basename(infile)))
			next
		end

		if(!$options[:force] && File.file?("#{$options[:insieme_builtins_dir]}/#{File.basename(infile)}"))
			puts "* Skipping already present #{$options[:insieme_builtins_dir]}/#{File.basename(infile)}\n" if !$options[:quiet]
			next
		end

		content = File.open(infile, "r").read

		# merge function and preprocessor pattern in a union
		stmt_match = content.scan(/(?:#{function_pattern})|(?:#{preprocessor_pattern})/)

		if stmt_match.size > 0

			decls_out = ""

			# handle functions, add types as they appear in parameters or as return types
			stmt_match.each do |func|
				if(func[3] != nil)
					# write preprocessor directives
					decls_out += "#{func[3]}\n\n"
				else
					# write prototype declaration consisting of return type, identifier and paramter list
					decls_out += "extern #{func[0]} #{func[1]} (#{func[2]});\n"
					# add return type to set of types
					types.add("#{func[0]}")
					# add each parameter type to set of types
					func[2].split(",").each do |param|
						param_list = param.strip.split(" ")
						# remove identifier if present, keep only type
						param_list = param_list[0...-1] if param_list.size > 1
						# add everything that is not an enum
						types.add("#{param_list.join(" ")}")
					end
				end
			end

			# save (possibly typedef'd) enums in hash
			# key is enum's concatenated identifier (before and after enumerator list, as only one of them may appear at a time)
			content.scan(enum_pattern).each do |x|
				enums["#{x[1]}#{x[3]}"] = "#{x[0]} enum #{x[1]} #{x[2]} #{x[3]};\n"
				# add enum names for later removal from types
				standard_tokens.push("#{x[1]}#{x[3]}")
			end
			# need to convert to array for elements to be modifieable
			types_arr = types.to_a
			# remove standard tokens from types, keep what is left
			types_arr.map!{ |x| x.gsub(/#{standard_tokens.join("|")}/,"").strip }.reject!{ |x| x.empty? }
			types = types_arr.to_set
			# put function declarations in file copies with the same name, write include directive for single file holding types and enums
			wrap_and_print("#include <#{types_header_filename}>\n\n" + decls_out, "#{$options[:insieme_builtins_dir]}/#{File.basename(infile)}")
		end
	end
end

if !enums.empty? || !types.empty?

	# concatenate enums
	enums_out = enums.map { |k,v| v }.join("\n")

	# concatenate types as empty struct typedefs
	types_out = types.map { |k| "typedef struct { } #{k.strip};" }.join("\n")

	# print enums and typedefs to separate file included by all others
	wrap_and_print(enums_out + "\n\n" + types_out, "#{$options[:insieme_builtins_dir]}/#{types_header_filename}")

end

# copy over the template file for the GCC intrinsics
FileUtils.cp("./#{gcc_builtins_filename_src}", "#{$options[:insieme_builtins_dir]}/#{gcc_builtins_filename_dst}")
