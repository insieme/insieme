#pragma once

#include "boolean.dl"
#include "ir.dl"
#include "reachable.dl"
#include "variable_definition_point.dl"
#include "return_value.dl"
#include "callable.dl"
#include "program_point_analysis.dl"


// -- a realation identifying every assignment --
.decl assignment ( e : expr ) output
assignment(c) :- NamedConstruct("ref_assign", i), NodeIdentity(t,i), callGraph(c,t).

// -- an under-approximation of assignments, computed without data flow analysis --
.decl simple_assignment ( e : expr ) output
simple_assignment(c) :- CallExpr(c,f), NamedConstruct("ref_assign", i), NodeIdentity(f,i).

// -- a realation identifying every deref operation --
.decl deref ( e : expr ) output
deref(c) :- NamedConstruct("ref_deref", i), NodeIdentity(t,i), callGraph(c,t).

// -- a generic data flow analysis --
.comp DataFlowAnalysis<ValueType> {
	
	// --------- interface ----------
	
	
	// the values to be assigned to all unknown values 
	.decl unknown_value( v : ValueType )

	// -- the value to be computed by this analysis --
	.decl value ( n : node , v : ValueType ) output

	
	// ------------------------------


	// -- value of variables --

	// definitions of variables take the value at the definition

	// declaration statements
	value( v, b ) :- VariableDefinition(v), DeclarationStmt(_,v,e), value(e,b).

	// bind parameters
	value( v, b ) :-
			VariableDefinition(v), NodeList(p,i,v), BindExpr(f,p,_),			// this variable is the i-th parameter of a bind expression f
			callGraph(c,f),														// f is called by call site c 
			NodeList(c,i,a),value(a,b).  										// v get's assigned the value of the i-th argument of c	
			
	// return variables
	value( v, b ) :- VariableDefinition(v), ReturnStmt(_,e,v), value(e,b). 

	// uses of variables correspond to the value of the definition point
	value( v, b ) :- Variable(v,_,_), DefinitionPoint(d,v), value(d,b).

	// free variables are undefined
	value( v, b ) :- FreeVariable(v), unknown_value(b).



	// -- value of call expressions --

	value( c, v ) :- CallExpr(c,f), callable_value(f,t), ReturnValue(t,r), ReachableIn(r), value(r,v). 



	// ------ Memory Locations ------
	
	// using a program point analysis to trace the memory location state
	.type memory_state = [ m : memory_location, v : ValueType ]
	.init memory_state = ProgramPointAnalysis<memory_state>


	// read value from a memory location
	value( c, v ) :- deref(c), NodeList(c,0,t), reference_value(t,m), memory_state.value(c,INT,[m,v]).

	// write values to memory locations (perfect assignment)
	memory_state.intercepted( c , INT ) :- simple_assignment(c).
	memory_state.value(c,POST,[m,v]) :- assignment(c), NodeList(c,0,t), NodeList(c,1,e), reference_value(t,m), value(e,v).
	memory_state.value(c,POST,s) :- assignment(c), NodeList(c,0,t), reference_value(t,m1), reference_value(t,m2), m1!=m2, memory_state.value(c,INT,s).
	
	
	// pass function argument to memory location of parameter
	memory_state.value( b, PRE, [v,d] ) :-  
			VariableDefinition(v), NodeList(p,i,v), Lambda(l,_,p,b),			// this variable is the i-th parameter of a lambda l
			callGraph(c,l),														// l is called by call site c 
			NodeList(c,i,a),value(a,d).  										// v get's assigned the value of the i-th argument of c

}

#include "reference.dl"
