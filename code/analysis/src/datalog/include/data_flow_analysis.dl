.using callGraph from Callable
.using VariableDefinition from VariableDefinitionPoint
.using DefinitionPoint from VariableDefinitionPoint
.using FreeVariable from VariableDefinitionPoint
.using callable_value from ForwardDecl
.using reference_value from ForwardDecl
.using ReturnValue from ReturnValue
.using ReachableIn from Reachable
.using concat from DataPath
.using ProgramPointAnalysis from ProgramPointAnalysis


// -- a realation identifying every assignment --
.decl assignment ( e : expr ) output
assignment(c) :- NamedConstruct("ref_assign", i), NodeIdentity(t,i), callGraph(c,t).

// -- an under-approximation of assignments, computed without data flow analysis --
.decl simple_assignment ( e : expr ) output
simple_assignment(c) :- CallExpr(c,f), NamedConstruct("ref_assign", i), NodeIdentity(f,i).

// -- a relation identifying every deref operation --
.decl deref ( e : expr ) output
deref(c) :- NamedConstruct("ref_deref", i), NodeIdentity(t,i), callGraph(c,t).

// -- a generic data flow analysis --
.comp DataFlowAnalysis<ValueType> {

	// --------- interface ----------


	// the values to be assigned to all unknown values
	.member unknown_value( v : ValueType )

	// -- the value to be computed by this analysis --
	.member value ( n : node , p : data_path , v : ValueType ) output


	// ------------------------------


	// -- value of variables --

	// definitions of variables take the value at the definition

	// declaration statements
	value( v, p, b ) :- VariableDefinition(v), DeclarationStmt(_,d,v), value(d,p,b).

	// bind parameters
	value( v, d, b ) :-
			VariableDefinition(v), NodeList(p,i,v), BindExpr(f,p,_),			// this variable is the i-th parameter of a bind expression f
			callGraph(c,f),														// f is called by call site c
			NodeList(c,i,a),value(a,d,b).  										// v get's assigned the value of the i-th argument of c

	// uses of variables correspond to the value of the definition point
	value( v, p, b ) :- Variable(v,_,_), DefinitionPoint(d,v), value(d,p,b).

	// free variables are undefined
	value( v, DP_ROOT, b ) :- FreeVariable(v), unknown_value(b).

	
	// -- values of declarations --
	
	// for now, just take the value of the initializer expression (TODO: handle ctor calls and implicit conversions)
	value( d, p, v ) :- Declaration(d,_,e), value(e,p,v). 


	// -- value of call expressions --

	value( c, p, v ) :- CallExpr(c,f), callable_value(f,DP_ROOT,t), ReturnValue(t,r), ReachableIn(r), value(r,p,v).



	// ------ Memory Locations ------

	// using a program point analysis to trace the memory location state
	.type memory_state = [ m : memory_location, v : ValueType ]
	.init memory_state = ProgramPointAnalysis<memory_state>


	// read value from a memory location
	value( c, vp, v ) :- deref(c), NodeList(c,0,t), reference_value(t,DP_ROOT, [m,rp]), memory_state.value(c,INT,[[m,p],v]), concat(rp,vp,p).

	// write values to memory locations (perfect assignment)
	memory_state.intercepted( c , INT ) :- simple_assignment(c).
	memory_state.value(c,POST,[[m,p],v]) :- assignment(c), NodeList(c,0,t), NodeList(c,1,e), reference_value(t,DP_ROOT,[m,p]), value(e,DP_ROOT,v).
	memory_state.value(c,POST,s) :- assignment(c), NodeList(c,0,t), reference_value(t,DP_ROOT,[m1,p1]), reference_value(t,DP_ROOT,[m2,p2]), (m1!=m2 ; p1!=p2), memory_state.value(c,INT,s).


	// pass function argument to memory location of parameter
	memory_state.value( b, PRE, [[v,dp],d] ) :-
			VariableDefinition(v), NodeList(p,i,v), Lambda(l,_,p,b),			// this variable is the i-th parameter of a lambda l
			callGraph(c,l),														// l is called by call site c
			NodeList(c,i,a),value(a,dp,d).  									// v get's assigned the value of the i-th argument of c

}

#include "reference.dl"
